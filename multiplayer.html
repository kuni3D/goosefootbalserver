<html>
<head>
    <meta http-equiv="Content-Security-Policy" content="
        script-src 'self' 'unsafe-eval' 'unsafe-inline' https://cdn.jsdelivr.net https://unpkg.com;
        connect-src 'self' wss://multiplayer-game-server-u7xz.onrender.com;
    ">
    <title>Pro Evolution Goose 25</title>
    <style>
        body { margin: 0; font-family: Arial, sans-serif; overflow: hidden; }
        canvas { display: block; width: 100vw; height: 100vh; }
        .header {
            position: absolute; top: 10px; left: 0; width: 100%;
            display: flex; justify-content: space-between; padding: 0 20px;
            box-sizing: border-box; color: #808080; font-size: clamp(16px, 2vw, 18px);
            z-index: 1; pointer-events: none;
        }
        .scoreboard {
            position: absolute; top: 40px; left: 50%; transform: translateX(-50%);
            color: #ffffff; font-size: 24px; text-align: center;
            background: rgba(0, 0, 0, 0.5); padding: 5px 15px; border-radius: 5px;
            z-index: 1;
        }
        .buttons {
            position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            z-index: 1; display: flex; gap: 10px;
        }
        button {
            padding: 5px 10px; font-size: 16px; background: #ffffff;
            border: none; border-radius: 5px; cursor: pointer;
        }
        button:hover {
            background: #e0e0e0;
        }
        #connectionStatus {
            position: absolute; top: 120px; left: 50%; transform: translateX(-50%);
            color: #ff0000; font-size: 18px; text-align: center;
            background: rgba(0, 0, 0, 0.5); padding: 5px 15px; border-radius: 5px;
            z-index: 1;
        }
    </style>
</head>
<body>
    <div class="header">
        <div>Goose Football '25</div>
        <div>by Kuni3D</div>
    </div>
    <div id="scoreboard" class="scoreboard">Equipo 1: 0 - Equipo 2: 0</div>
    <div class="buttons">
        <button id="resetBallButton">Reiniciar Pelota</button>
        <button id="resetGameButton">Reiniciar Partida</button>
    </div>
    <div id="connectionStatus">Conectando al servidor...</div>

    <script src="https://unpkg.com/three@0.134.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.134.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.134.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.134.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.134.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.134.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.134.0/examples/js/shaders/ColorCorrectionShader.js"></script>

    <script>
        let playerId = Date.now().toString();
        let playerNumber = null;
        const roomId = "game1";
        let socket;
        let isConnected = false;
        const connectionStatus = document.getElementById('connectionStatus');

        let scene, camera, renderer, composer, clock;
        let playerModel, opponentModel, playerMixer, opponentMixer;
        let ball, velocity = new THREE.Vector3(0, 0, 0);
        let team1Score = 0, team2Score = 0;
        const scoreboard = document.getElementById('scoreboard');
        const speed = 0.1;
        const roomSizeX = 1.4;
        const roomSizeZ = 2.35;
        const GRAVITY = -0.001;

        const keys = { w: false, a: false, s: false, d: false, space: false };

        function connectWebSocket() {
            console.log(`Intentando conectar al WebSocket con roomId: ${roomId}, playerId: ${playerId}`);
            socket = new WebSocket(`wss://multiplayer-game-server-u7xz.onrender.com${roomId}:${playerId}`);

            socket.onopen = () => {
                console.log('Conectado al servidor WebSocket');
                isConnected = true;
                connectionStatus.textContent = 'Conectado al servidor';
                connectionStatus.style.color = '#00ff00';
            };

            socket.onerror = (error) => {
                console.error('Error en WebSocket:', error);
                isConnected = false;
                connectionStatus.textContent = 'Error al conectar al servidor';
                connectionStatus.style.color = '#ff0000';
            };

            socket.onclose = () => {
                console.log('Conexión WebSocket cerrada, intentando reconectar...');
                isConnected = false;
                connectionStatus.textContent = 'Conexión perdida, reconectando...';
                connectionStatus.style.color = '#ff0000';
                setTimeout(connectWebSocket, 3000);
            };

            socket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                console.log('Mensaje recibido:', data);

                if (data.type === 'playerId') {
                    playerId = data.id;
                    playerNumber = data.playerNumber;
                    console.log('Soy el jugador', playerId, 'Número:', playerNumber);
                } else if (data.type === 'characterPosition') {
                    if (data.playerId !== playerId) {
                        console.log('Recibida posición del otro jugador:', data);
                        const otherModel = playerNumber === 1 ? opponentModel : playerModel;
                        if (otherModel) {
                            otherModel.position.set(data.x, data.y, data.z);
                            otherModel.rotation.y = data.rotationY;
                            const mixer = playerNumber === 1 ? opponentMixer : playerMixer;
                            if (mixer && otherModel.animations[data.action]) {
                                if (otherModel.currentAction !== data.action) {
                                    if (otherModel.animations[otherModel.currentAction]) {
                                        otherModel.animations[otherModel.currentAction].fadeOut(0.25);
                                    }
                                    otherModel.animations[data.action].reset().fadeIn(0.25).play();
                                    otherModel.currentAction = data.action;
                                    console.log(`Animación ${data.action} aplicada al otro jugador`);
                                }
                            } else {
                                console.warn('No se pudo aplicar la animación:', data.action);
                            }
                        } else {
                            console.warn('Modelo del otro jugador no está listo');
                        }
                    }
                } else if (data.type === 'ballPosition') {
                    if (ball && data.playerId !== playerId) {
                        ball.position.set(data.x, data.y, data.z);
                        velocity.set(data.vx, data.vy, data.vz);
                        console.log('Pelota sincronizada:', ball.position);
                    }
                } else if (data.type === 'score') {
                    team1Score = data.team1Score;
                    team2Score = data.team2Score;
                    updateScoreboard();
                } else if (data.type === 'resetBall') {
                    if (ball) {
                        ball.position.set(0, 0, 0);
                        velocity.set(0, 0, 0);
                    }
                } else if (data.type === 'resetGame') {
                    if (ball) {
                        ball.position.set(0, 0, 0);
                        velocity.set(0, 0, 0);
                        team1Score = 0;
                        team2Score = 0;
                        updateScoreboard();
                    }
                }
            };
        }

        connectWebSocket();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            composer = new THREE.EffectComposer(renderer);
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);

            const colorCorrectionPass = new THREE.ShaderPass(THREE.ColorCorrectionShader);
            colorCorrectionPass.uniforms['powRGB'].value = new THREE.Vector3(1, 1, 1);
            colorCorrectionPass.uniforms['mulRGB'].value = new THREE.Vector3(0.7, 0.7, 0.7);
            colorCorrectionPass.uniforms['addRGB'].value = new THREE.Vector3(0.31, 0.3, 0.3);
            composer.addPass(colorCorrectionPass);

            const ambientLight = new THREE.AmbientLight(0xC9E6F0, 1.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 20;
            directionalLight.shadow.bias = -0.01;
            scene.add(directionalLight);

            clock = new THREE.Clock();

            const goalWidth = 1.3;
            const goalHeight = 0.7;
            const goalDepth = 0.2;
            const postRadius = 0.05;
            const postMaterial = new THREE.MeshBasicMaterial({ color: 0xE4E4E4 });

            const leftPost = new THREE.Mesh(new THREE.CylinderGeometry(postRadius, postRadius, goalHeight, 32), postMaterial);
            leftPost.position.set(-goalWidth / 2, goalHeight - 1 / 2, -2.35);
            leftPost.name = 'leftPost';
            scene.add(leftPost);

            const rightPost = new THREE.Mesh(new THREE.CylinderGeometry(postRadius, postRadius, goalHeight, 32), postMaterial);
            rightPost.position.set(goalWidth / 2, goalHeight - 1 / 2, -2.35);
            rightPost.name = 'rightPost';
            scene.add(rightPost);

            const crossbar = new THREE.Mesh(new THREE.CylinderGeometry(postRadius, postRadius, goalWidth, 32), postMaterial);
            crossbar.position.set(0, goalHeight - 0.18, -2.35);
            crossbar.rotation.z = Math.PI / 2;
            crossbar.name = 'crossbar';
            scene.add(crossbar);

            const leftPost2 = new THREE.Mesh(new THREE.CylinderGeometry(postRadius, postRadius, goalHeight, 32), postMaterial);
            leftPost2.position.set(-goalWidth / 2, goalHeight - 1 / 2, 2.35);
            leftPost2.name = 'leftPost2';
            scene.add(leftPost2);

            const rightPost2 = new THREE.Mesh(new THREE.CylinderGeometry(postRadius, postRadius, goalHeight, 32), postMaterial);
            rightPost2.position.set(goalWidth / 2, goalHeight - 1 / 2, 2.35);
            rightPost2.name = 'rightPost2';
            scene.add(rightPost2);

            const crossbar2 = new THREE.Mesh(new THREE.CylinderGeometry(postRadius, postRadius, goalWidth, 32), postMaterial);
            crossbar2.position.set(0, goalHeight - 0.18, 2.35);
            crossbar2.rotation.z = Math.PI / 2;
            crossbar2.name = 'crossbar2';
            scene.add(crossbar2);

            const loader = new THREE.GLTFLoader();
            loader.load('/pelotita2.glb', (gltf) => {
                const model = gltf.scene;
                console.log('Modelo cargado:', model);
                model.traverse((child) => {
                    if (child.isMesh) {
                        console.log('Mesh encontrado:', child.name, 'Posición:', child.position);
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                    if (child.isBone) {
                        console.log('Hueso encontrado:', child.name);
                    }
                });
                scene.add(model);

                let brickGeometry = null;
                let brickMaterial = null;
                const brickInstances = new Array(1292);
                const bricksToRemove = [];

                model.traverse((child) => {
                    if (child.isMesh) {
                        if (child.name === 'ladrillo' && !brickGeometry) {
                            brickGeometry = child.geometry.clone();
                            brickMaterial = new THREE.MeshPhongMaterial({ color: 0x7B7B7B });
                            console.log('Geometría base encontrada en "ladrillo"');
                        }
                        const match = child.name.match(/^ladrillo(\d+)?$/);
                        if (match) {
                            const index = match[1] ? parseInt(match[1], 10) - 1 : 0;
                            if (index >= 0 && index < 1292) {
                                const matrix = new THREE.Matrix4()
                                    .makeRotationFromQuaternion(child.quaternion)
                                    .scale(child.scale)
                                    .setPosition(child.position);
                                brickInstances[index] = matrix;
                                bricksToRemove.push(child);
                                console.log(`Ladrillo ${child.name} asignado al índice ${index}, Posición:`, child.position, 'Escala:', child.scale);
                            }
                        }
                    }
                });

                if (brickGeometry && brickInstances.some(m => m !== undefined)) {
                    const instancedBricks = new THREE.InstancedMesh(brickGeometry, brickMaterial, 1292);
                    instancedBricks.castShadow = true;
                    instancedBricks.receiveShadow = true;

                    brickInstances.forEach((matrix, index) => {
                        if (matrix) {
                            instancedBricks.setMatrixAt(index, matrix);
                        }
                    });

                    instancedBricks.instanceMatrix.needsUpdate = true;
                    scene.add(instancedBricks);
                    console.log(`Éxito: ${brickInstances.filter(m => m !== undefined).length} de 1292 ladrillos instanciados`);

                    bricksToRemove.forEach((brick) => {
                        brick.parent.remove(brick);
                    });
                } else {
                    console.error('Fallo: No se encontró "ladrillo" o no hay instancias válidas');
                }

                ball = model.getObjectByName('pelota');
                if (!ball) console.error('No se encontró la pelota en el modelo');
                else console.log('Pelota asignada:', ball);

                playerModel = model.getObjectByName('ganzito');
                const armature = model.getObjectByName('armature');
                if (playerModel && armature) {
                    console.log('Ganzito y armature encontrados');
                    playerModel = armature;
                    playerMixer = new THREE.AnimationMixer(playerModel);
                    playerModel.animations = {};
                    const animationNames = ['idlecomun', 'correr', 'patear'];
                    gltf.animations.forEach((clip) => {
                        const clipNameLower = clip.name.toLowerCase();
                        if (animationNames.includes(clipNameLower)) {
                            playerModel.animations[clipNameLower] = playerMixer.clipAction(clip);
                            playerModel.animations[clipNameLower].setLoop(clipNameLower === 'patear' ? THREE.LoopOnce : THREE.LoopRepeat);
                            console.log(`Animación para ganzito ${clipNameLower} cargada, duración: ${clip.duration} segundos`);
                        }
                    });
                    if (playerModel.animations['idlecomun']) {
                        playerModel.animations['idlecomun'].play();
                        playerModel.currentAction = 'idlecomun';
                        console.log('idlecomun iniciado para ganzito');
                    }
                } else {
                    console.error('Falta ganzito o armature en el modelo');
                }

                opponentModel = model.getObjectByName('ganzit2');
                const armatur2 = model.getObjectByName('armatur2');
                if (opponentModel && armatur2) {
                    console.log('Ganzit2 y armatur2 encontrados');
                    opponentModel = armatur2;
                    opponentModel.position.set(0, 0.11, 0);
                    opponentMixer = new THREE.AnimationMixer(opponentModel);
                    opponentModel.animations = {};
                    const animationNames2 = ['2quieto', '2corre', '2patea'];
                    gltf.animations.forEach((clip) => {
                        const clipNameLower = clip.name.toLowerCase();
                        if (animationNames2.includes(clipNameLower)) {
                            opponentModel.animations[clipNameLower] = opponentMixer.clipAction(clip);
                            opponentModel.animations[clipNameLower].setLoop(clipNameLower === '2patea' ? THREE.LoopOnce : THREE.LoopRepeat);
                            console.log(`Animación para ganzit2 ${clipNameLower} cargada, duración: ${clip.duration} segundos`);
                        }
                    });
                    if (opponentModel.animations['2quieto']) {
                        opponentModel.animations['2quieto'].play();
                        opponentModel.currentAction = '2quieto';
                        console.log('2quieto iniciado para ganzit2');
                    }
                } else {
                    console.warn('No se encontraron ganzit2 o armatur2 en el modelo');
                }

                camera.position.set(0, 5, 10);
                camera.lookAt(0, 0, 0);
            }, undefined, (error) => {
                console.error('Error al cargar el modelo:', error);
            });

            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 5;
            controls.maxDistance = 20;
            controls.maxPolarAngle = Math.PI / 2.2;
        }

        init();

        function updateScoreboard() {
            scoreboard.textContent = `Equipo 1: ${team1Score} - Equipo 2: ${team2Score}`;
        }

        window.addEventListener('keydown', (event) => {
            const key = event.key.toLowerCase();
            const code = event.code;
            console.log('Tecla presionada:', key, 'Código:', code);

            if (key === 'w' || code === 'KeyW') keys.w = true;
            if (key === 'a' || code === 'KeyA') keys.a = true;
            if (key === 's' || code === 'KeyS') keys.s = true;
            if (key === 'd' || code === 'KeyD') keys.d = true;
            if (key === ' ' || code === 'Space') keys.space = true;

            console.log(`Tecla ${key} (código: ${code}) presionada, keys:`, keys);
        });

        window.addEventListener('keyup', (event) => {
            const key = event.key.toLowerCase();
            const code = event.code;

            if (key === 'w' || code === 'KeyW') keys.w = false;
            if (key === 'a' || code === 'KeyA') keys.a = false;
            if (key === 's' || code === 'KeyS') keys.s = false;
            if (key === 'd' || code === 'KeyD') keys.d = false;
            if (key === ' ' || code === 'Space') keys.space = false;

            console.log(`Tecla ${key} (código: ${code}) soltada, keys:`, keys);
        });

        const ballBox = new THREE.Box3();
        const playerBox = new THREE.Box3();
        const opponentBox = new THREE.Box3();
        const leftPostBox = new THREE.Box3();
        const rightPostBox = new THREE.Box3();
        const crossbarBox = new THREE.Box3();
        const leftPost2Box = new THREE.Box3();
        const rightPost2Box = new THREE.Box3();
        const crossbar2Box = new THREE.Box3();

        const goalArea1 = {
            minX: -1.3 / 2, maxX: 1.3 / 2,
            minY: 0, maxY: 0.7,
            minZ: -2.3 - 0.2 / 2, maxZ: -2.3 + 0.2 / 2,
        };

        const goalArea2 = {
            minX: -1.3 / 2, maxX: 1.3 / 2,
            minY: 0, maxY: 0.7,
            minZ: 2.3 - 0.2 / 2, maxZ: 2.3 + 0.2 / 2,
        };

        let fireworks = [];

        function createFireworks(x, y, z) {
            const particleCount = 50;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const velocities = [];

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                const color = new THREE.Color();
                color.setHSL(Math.random(), 1.0, 0.5);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;

                velocities.push(
                    new THREE.Vector3(
                        (Math.random() - 0.5) * 0.1,
                        Math.random() * 0.15,
                        (Math.random() - 0.5) * 0.1
                    )
                );
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.05,
                vertexColors: true,
                transparent: true,
                opacity: 1.0
            });

            const firework = new THREE.Points(geometry, material);
            firework.userData = { velocities, life: 2.0 };
            scene.add(firework);
            fireworks.push(firework);
        }

        function updateFireworks() {
            for (let i = fireworks.length - 1; i >= 0; i--) {
                const firework = fireworks[i];
                const positions = firework.geometry.attributes.position.array;
                const velocities = firework.userData.velocities;
                firework.userData.life -= 0.016;

                for (let j = 0; j < positions.length / 3; j++) {
                    positions[j * 3] += velocities[j].x;
                    positions[j * 3 + 1] += velocities[j].y - 0.002;
                    positions[j * 3 + 2] += velocities[j].z;
                    velocities[j].y -= 0.001;
                }

                firework.geometry.attributes.position.needsUpdate = true;
                firework.material.opacity = firework.userData.life / 2.0;

                if (firework.userData.life <= 0) {
                    scene.remove(firework);
                    fireworks.splice(i, 1);
                }
            }
        }

        function isBallInGoal() {
            if (!ball) return false;
            const ballPosition = ball.position;

            const inGoal1 = (
                ballPosition.x >= goalArea1.minX && ballPosition.x <= goalArea1.maxX &&
                ballPosition.y >= goalArea1.minY && ballPosition.y <= goalArea1.maxY &&
                ballPosition.z >= goalArea1.minZ && ballPosition.z <= goalArea1.maxZ
            );

            const inGoal2 = (
                ballPosition.x >= goalArea2.minX && ballPosition.x <= goalArea2.maxX &&
                ballPosition.y >= goalArea2.minY && ballPosition.y <= goalArea2.maxY &&
                ballPosition.z >= goalArea2.minZ && ballPosition.z <= goalArea2.maxZ
            );

            if (inGoal1) {
                console.log("¡Gol en el arco del Equipo 1! Punto para Equipo 2");
                team2Score++;
                ball.position.set(0, 0, 0);
                velocity.set(0, 0, 0);
                if (isConnected) socket.send(JSON.stringify({ type: 'score', team1Score, team2Score }));
                createFireworks(0, 2, -2.3);
                updateScoreboard();
                return true;
            } else if (inGoal2) {
                console.log("¡Gol en el arco del Equipo 2! Punto para Equipo 1");
                team1Score++;
                ball.position.set(0, 0, 0);
                velocity.set(0, 0, 0);
                if (isConnected) socket.send(JSON.stringify({ type: 'score', team1Score, team2Score }));
                createFireworks(0, 2, 2.3);
                updateScoreboard();
                return true;
            }
            return false;
        }

        function checkCollisions() {
            if (!ball) return;
            ballBox.setFromObject(ball);

            const leftPostObj = scene.getObjectByName('leftPost');
            const rightPostObj = scene.getObjectByName('rightPost');
            const crossbarObj = scene.getObjectByName('crossbar');
            const leftPost2Obj = scene.getObjectByName('leftPost2');
            const rightPost2Obj = scene.getObjectByName('rightPost2');
            const crossbar2Obj = scene.getObjectByName('crossbar2');

            if (leftPostObj) leftPostBox.setFromObject(leftPostObj);
            if (rightPostObj) rightPostBox.setFromObject(rightPostObj);
            if (crossbarObj) crossbarBox.setFromObject(crossbarObj);
            if (leftPost2Obj) leftPost2Box.setFromObject(leftPost2Obj);
            if (rightPost2Obj) rightPost2Box.setFromObject(rightPost2Obj);
            if (crossbar2Obj) crossbar2Box.setFromObject(crossbar2Obj);

            if ((leftPostObj && ballBox.intersectsBox(leftPostBox)) ||
                (rightPostObj && ballBox.intersectsBox(rightPostBox)) ||
                (crossbarObj && ballBox.intersectsBox(crossbarBox)) ||
                (leftPost2Obj && ballBox.intersectsBox(leftPost2Box)) ||
                (rightPost2Obj && ballBox.intersectsBox(rightPost2Box)) ||
                (crossbar2Obj && ballBox.intersectsBox(crossbar2Box))) {
                velocity.x = -velocity.x;
                velocity.z = -velocity.z;
            }
        }

        function checkCharacterBallCollision() {
            if (!ball) return false;
            let collided = false;

            if (playerNumber === 1 && playerModel) {
                ballBox.setFromObject(ball);
                ballBox.expandByScalar(0.08);
                playerBox.setFromObject(playerModel);
                playerBox.expandByScalar(0.09);

                if (ballBox.intersectsBox(playerBox)) {
                    let direction = new THREE.Vector3(0, 0, 0);
                    if (keys.w) direction.z = -1;
                    if (keys.s) direction.z = 1;
                    if (keys.a) direction.x = -1;
                    if (keys.d) direction.x = 1;
                    direction.normalize();
                    const kickForce = 0.01;
                    velocity.x += direction.x * kickForce;
                    velocity.z += direction.z * kickForce;
                    collided = true;
                }
            } else if (playerNumber === 2 && opponentModel) {
                ballBox.setFromObject(ball);
                ballBox.expandByScalar(0.08);
                opponentBox.setFromObject(opponentModel);
                opponentBox.expandByScalar(0.09);

                if (ballBox.intersectsBox(opponentBox)) {
                    let direction = new THREE.Vector3(0, 0, 0);
                    if (keys.w) direction.z = -1;
                    if (keys.s) direction.z = 1;
                    if (keys.a) direction.x = -1;
                    if (keys.d) direction.x = 1;
                    direction.normalize();
                    const kickForce = 0.01;
                    velocity.x += direction.x * kickForce;
                    velocity.z += direction.z * kickForce;
                    collided = true;
                }
            }

            return collided;
        }

        function checkKickCollision() {
            if (!ball) return false;
            let kicked = false;

            if (playerNumber === 1 && playerModel && playerModel.currentAction === 'patear') {
                ballBox.setFromObject(ball);
                ballBox.expandByScalar(0.1);
                playerBox.setFromObject(playerModel);
                playerBox.expandByScalar(0.2);

                const kickTime = playerModel.animations['patear'].getClip().duration * 0.5;
                const currentTime = playerModel.animations['patear'].time;
                const kickWindow = 0.1;

                if (Math.abs(currentTime - kickTime) < kickWindow && ballBox.intersectsBox(playerBox)) {
                    const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(playerModel.quaternion).normalize();
                    const kickForce = 0.1;
                    const liftForce = 0.03;
                    velocity.x = direction.x * kickForce;
                    velocity.z = direction.z * kickForce;
                    velocity.y = liftForce;
                    kicked = true;
                }
            } else if (playerNumber === 2 && opponentModel && opponentModel.currentAction === '2patea') {
                ballBox.setFromObject(ball);
                ballBox.expandByScalar(0.1);
                opponentBox.setFromObject(opponentModel);
                opponentBox.expandByScalar(0.2);

                const kickTime = opponentModel.animations['2patea'].getClip().duration * 0.5;
                const currentTime = opponentModel.animations['2patea'].time;
                const kickWindow = 0.1;

                if (Math.abs(currentTime - kickTime) < kickWindow && ballBox.intersectsBox(opponentBox)) {
                    const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(opponentModel.quaternion).normalize();
                    const kickForce = 0.1;
                    const liftForce = 0.03;
                    velocity.x = direction.x * kickForce;
                    velocity.z = direction.z * kickForce;
                    velocity.y = liftForce;
                    kicked = true;
                }
            }
            return kicked;
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if (playerMixer) playerMixer.update(delta);
            if (opponentMixer) opponentMixer.update(delta);

            let myModel, myMixer, runAnimation, idleAnimation, kickAnimation;
            if (playerNumber === 1) {
                myModel = playerModel;
                myMixer = playerMixer;
                runAnimation = 'correr';
                idleAnimation = 'idlecomun';
                kickAnimation = 'patear';
            } else if (playerNumber === 2) {
                myModel = opponentModel;
                myMixer = opponentMixer;
                runAnimation = '2corre';
                idleAnimation = '2quieto';
                kickAnimation = '2patea';
            }

            if (myModel) {
                console.log('Controlando al jugador:', playerNumber, 'Modelo:', myModel ? myModel.name : 'No asignado');

                const direction = new THREE.Vector3();
                if (keys.w) direction.z -= 1;
                if (keys.s) direction.z += 1;
                if (keys.a) direction.x -= 1;
                if (keys.d) direction.x += 1;
                direction.normalize().multiplyScalar(speed);
                myModel.position.add(direction);

                if (direction.length() > 0) {
                    myModel.rotation.y = Math.atan2(direction.x, direction.z);
                    if (myModel.currentAction !== runAnimation && myModel.animations[runAnimation]) {
                        if (myModel.animations[myModel.currentAction]) {
                            myModel.animations[myModel.currentAction].fadeOut(0.25);
                        }
                        myModel.animations[runAnimation].reset().fadeIn(0.25).play();
                        myModel.currentAction = runAnimation;
                    }
                } else if ((myModel.currentAction === 'correr' || myModel.currentAction === '2corre') && myModel.animations[idleAnimation]) {
                    if (myModel.animations[myModel.currentAction]) {
                        myModel.animations[myModel.currentAction].fadeOut(0.25);
                    }
                    myModel.animations[idleAnimation].reset().fadeIn(0.25).play();
                    myModel.currentAction = idleAnimation;
                }

                if (keys.space && myModel.animations[kickAnimation]) {
                    if (myModel.animations[myModel.currentAction]) {
                        myModel.animations[myModel.currentAction].fadeOut(0.25);
                    }
                    myModel.animations[kickAnimation].reset().fadeIn(0.25).play();
                    myModel.currentAction = kickAnimation;

                    const message = {
                        type: 'characterPosition',
                        playerId: playerId,
                        character: playerNumber === 1 ? 'ganzito' : 'ganzit2',
                        x: myModel.position.x,
                        y: myModel.position.y,
                        z: myModel.position.z,
                        rotationY: myModel.rotation.y,
                        action: myModel.currentAction
                    };
                    if (isConnected) {
                        socket.send(JSON.stringify(message));
                        console.log('Enviada posición con patada:', message);
                    }
                    myModel.animations[kickAnimation].getMixer().addEventListener('finished', (e) => {
                        if (e.action === myModel.animations[kickAnimation] && myModel.animations[idleAnimation]) {
                            myModel.animations[kickAnimation].stop();
                            myModel.animations[idleAnimation].reset().play();
                            myModel.currentAction = idleAnimation;
                            const message = {
                                type: 'characterPosition',
                                playerId: playerId,
                                character: playerNumber === 1 ? 'ganzito' : 'ganzit2',
                                x: myModel.position.x,
                                y: myModel.position.y,
                                z: myModel.position.z,
                                rotationY: myModel.rotation.y,
                                action: myModel.currentAction
                            };
                            if (isConnected) {
                                socket.send(JSON.stringify(message));
                                console.log('Enviada posición después de patada:', message);
                            }
                        }
                    }, { once: true });
                } else {
                    const message = {
                        type: 'characterPosition',
                        playerId: playerId,
                        character: playerNumber === 1 ? 'ganzito' : 'ganzit2',
                        x: myModel.position.x,
                        y: myModel.position.y,
                        z: myModel.position.z,
                        rotationY: myModel.rotation.y,
                        action: myModel.currentAction
                    };
                    if (isConnected) {
                        socket.send(JSON.stringify(message));
                        console.log('Enviada posición:', message);
                    }
                }
            } else {
                console.warn('Esperando asignación de playerNumber...');
            }

            if (ball) {
                velocity.y += GRAVITY;
                ball.position.add(velocity);
                if (ball.position.y < 0) {
                    ball.position.y = 0;
                    velocity.y *= -0.5;
                }
                if (Math.abs(ball.position.x) > roomSizeX) velocity.x = -velocity.x;
                if (Math.abs(ball.position.z) > roomSizeZ) velocity.z = -velocity.z;
                velocity.multiplyScalar(0.99);

                if (isConnected) {
                    const ballMessage = {
                        type: 'ballPosition',
                        playerId: playerId,
                        x: ball.position.x,
                        y: ball.position.y,
                        z: ball.position.z,
                        vx: velocity.x,
                        vy: velocity.y,
                        vz: velocity.z
                    };
                    socket.send(JSON.stringify(ballMessage));
                    console.log('Enviada posición de la pelota:', ballMessage);
                }
            }

            checkCollisions();
            checkCharacterBallCollision();
            checkKickCollision();
            isBallInGoal();
            updateFireworks();
            composer.render();
        }

        animate();

        function resetBall() {
            console.log('Botón "Reiniciar pelota" presionado');
            if (ball) {
                ball.position.set(0, 0, 0);
                velocity.set(0, 0, 0);
                console.log('Pelota reiniciada a posición:', ball.position, 'Velocidad:', velocity);
                if (isConnected) {
                    socket.send(JSON.stringify({
                        type: 'ballPosition',
                        playerId: playerId,
                        x: ball.position.x,
                        y: ball.position.y,
                        z: ball.position.z,
                        vx: velocity.x,
                        vy: velocity.y,
                        vz: velocity.z
                    }));
                }
            } else {
                console.error('No se encontró la pelota para reiniciar');
            }
        }

        function resetGame() {
            console.log('Botón "Reiniciar partida" presionado');
            if (ball) {
                ball.position.set(0, 0, 0);
                velocity.set(0, 0, 0);
                console.log('Pelota reiniciada a posición:', ball.position, 'Velocidad:', velocity);
            } else {
                console.error('No se encontró la pelota para reiniciar');
            }

            team1Score = 0;
            team2Score = 0;
            console.log('Puntajes reiniciados: Equipo 1:', team1Score, 'Equipo 2:', team2Score);
            updateScoreboard();

            if (isConnected) {
                socket.send(JSON.stringify({ type: 'score', team1Score, team2Score }));
                socket.send(JSON.stringify({
                    type: 'ballPosition',
                    playerId: playerId,
                    x: ball.position.x,
                    y: ball.position.y,
                    z: ball.position.z,
                    vx: velocity.x,
                    vy: velocity.y,
                    vz: velocity.z
                }));
            }
        }

        document.getElementById('resetBallButton')?.addEventListener('click', () => {
            console.log('Evento click en resetBallButton detectado');
            resetBall();
        });

        document.getElementById('resetGameButton')?.addEventListener('click', () => {
            console.log('Evento click en resetGameButton detectado');
            resetGame();
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
